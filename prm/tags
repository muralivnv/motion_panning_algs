!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
A_star	Astar.h	/^std::vector<as_node*> A_star(Node* src, Node* goal)$/;"	f
G	PRM.h	/^    Graph* G;$/;"	m	class:PRM
Graph	Graph.h	/^class Graph{$/;"	c
Node	Node.h	/^    Node(int x, int y) : pos_x(x), pos_y(y){}$/;"	f	struct:Node
Node	Node.h	/^struct Node{$/;"	s
PRM	PRM.h	/^    PRM(int x, int y ): map_size_x(x), $/;"	f	class:PRM
PRM	PRM.h	/^class PRM{$/;"	c
_prm_DIJKSTRA_H_	Astar.h	2;"	d
_prm_GRAPH_H_	Graph.h	2;"	d
_prm_NODE_H_	Node.h	2;"	d
_prm_PRM_H_	PRM.h	2;"	d
add_vertex	Graph.h	/^void Graph::add_vertex(Node* q)$/;"	f	class:Graph
as_node	Astar.h	/^    as_node(Node* n) : node(n){}$/;"	f	struct:as_node
as_node	Astar.h	/^struct as_node{$/;"	s
calculate_node_weight	Astar.h	/^void calculate_node_weight(as_node* parent, as_node* current_node, Node* goal)$/;"	f
connected_vertices	Node.h	/^    std::vector<Node*> connected_vertices;$/;"	m	struct:Node
contains	Astar.h	/^contains(std::vector<as_node*>& list, as_node* node)$/;"	f
create_edge	Graph.h	/^void Graph::create_edge(Node* q1, Node* q2)$/;"	f	class:Graph
create_road_map	PRM.h	/^void PRM::create_road_map(int num_of_vertices, int n_neighbours)$/;"	f	class:PRM
f_cost	Astar.h	/^    int f_cost()$/;"	f	struct:as_node
g_cost	Astar.h	/^    int g_cost = 0.0, h_cost = 0.0;$/;"	m	struct:as_node
get_graph	PRM.h	/^Graph* PRM::get_graph()$/;"	f	class:PRM
get_neighbour_node	Graph.h	/^std::vector<Node*> Graph::get_neighbour_node(Node* q, int n_neighbours)$/;"	f	class:Graph
get_node	Graph.h	/^Node* Graph::get_node(int idx)$/;"	f	class:Graph
goal_x_	PRM.h	/^    int goal_x_ = 0.0, goal_y_ = 0.0;$/;"	m	class:PRM
goal_y_	PRM.h	/^    int goal_x_ = 0.0, goal_y_ = 0.0;$/;"	m	class:PRM
h_cost	Astar.h	/^    int g_cost = 0.0, h_cost = 0.0;$/;"	m	struct:as_node
is_edge_collision_free	PRM.h	/^bool PRM::is_edge_collision_free(Node* q1, Node* q2)$/;"	f	class:PRM
is_edge_exist	Graph.h	/^bool Graph::is_edge_exist(Node* q1, Node* q2)$/;"	f	class:Graph
main	test_prm.cpp	/^int main()$/;"	f
map_size_x	PRM.h	/^    int map_size_x = 0.0, map_size_y = 0.0;$/;"	m	class:PRM
map_size_y	PRM.h	/^    int map_size_x = 0.0, map_size_y = 0.0;$/;"	m	class:PRM
new_edge	PRM.h	/^void PRM::new_edge(Node* q1, Node* q2)$/;"	f	class:PRM
new_vertex	PRM.h	/^void PRM::new_vertex(int x, int y)$/;"	f	class:PRM
node	Astar.h	/^    Node* node;$/;"	m	struct:as_node
num_of_vertices	Graph.h	/^int Graph::num_of_vertices()$/;"	f	class:Graph
pos_x	Node.h	/^    double pos_x = 0.0, pos_y = 0.0;$/;"	m	struct:Node
pos_y	Node.h	/^    double pos_x = 0.0, pos_y = 0.0;$/;"	m	struct:Node
push_neighbours_to_list	Astar.h	/^bool push_neighbours_to_list(   std::vector<as_node*>& open_list,$/;"	f
set_goal	PRM.h	/^    void set_goal (int x, int y){$/;"	f	class:PRM
set_start	PRM.h	/^    void set_start(int x, int y){$/;"	f	class:PRM
start_x_	PRM.h	/^    int start_x_ = 0.0, start_y_ = 0.0;$/;"	m	class:PRM
start_y_	PRM.h	/^    int start_x_ = 0.0, start_y_ = 0.0;$/;"	m	class:PRM
update_road_map	PRM.h	/^std::vector<Node*> PRM::update_road_map(int n_neighbours)$/;"	f	class:PRM
vertices	Graph.h	/^    std::vector<Node*> vertices;$/;"	m	class:Graph
